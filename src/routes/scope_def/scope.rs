pub fn scope() {
    /*
    String : 다른 문자열 타입 -> 이 타입은 힙에 할당된 데이터를 다룸 
        -> 컴파일 타임에 크기를 알 수 없는 텍스트도 저장할 수 있다. -> 실행 중 메모리 할당자로부터 메모리를 요청해야됨 / String 사용을 마쳤을 때 메모리를 해제할 방법이 필요
    */
    //이중 콜론(::) : 우리가 함수를 사용할 때 string_from 같은 함수명을 사용하지 않고 String 타입에 있는 특정된 from 함수라는 것을 지정할 수 있게 해주는 에미스페이스 연산자이다.
    let hello = String::from("hello"); //hello는 이 지점부터 유효

    println!("String::from을 사용 : {hello}"); //hello을 가지고 무언가 한다.

    /*
    s1에 저장된 내용은 포인터, 길이(String의 내용이 현재 사용하고 있는 메모리의 바이트 단위), 용량(메모리 할당자가 String에 할당한 메모리의 양) 이다.
        -> 해당 내용이 스택에 저장 문자열 내용은 힙 메모리에 저장
    s2에 s1을 대입하면 String 데이터가 복사된다. 이때 데이터는 스택에 있는 데이터 즉 포인터, 길이, 용량 값을 말하며 포인터가 가르키는 힙 영역의 데이터는 복사되지 않는다.
     */
    let s1 = String::from("hello");
    let s2 = s1;
    /*
    s2, s1이 스코프 밖으로 벗어날 때 각각 메모리를 해제하게 되면 중복 해제(double free)에러가 발생한다. -> 메모리 안정성 버그 중 하나이며 보안을 취약하게 만드는 메모리 손상의 원인
        -> 메모리 안정성을 보장하기 위해서는 let s2 = s1; 라인 뒤로는 s1이 더 이상 유효하지 않다고 판단 -> 해당 println!("{}, world!", s1); 는 에러가 발생한다.
    다른 언어에서는 '얕은복사(shallow copy)', '깊은 복사(deep copy)'를 러스트에서는 '이동(move)', 'clone' 이라는 공용 메서드를 사용
    */
    println!("이동(move) :  {s2}");

    let s3 = String::from("hello");
    let s4 = s3.clone();

    println!("s3 = {s3}, s4 = {s4}");
    /*
    clone 호출을 보고, 이 지점에서 성은ㅇ에 영향이 갈 수도 있는 코드가 실행될 것을 알 수 있다. clone은 해당 위치에서 무언가 다른 일이 수행될 것을 알려주는 시각적인 표시이기도 하다.
    */

    let x = 5;
    let y = x;
    
    println!("x : {x}, y : {y}");
    /*
    정수형 등 컴파일 타임에 크기가 고정되는 타입은 모두 스택에 저장되기 때문에 궅이 y를 생성하고 x를 무효화할 필요가 없다.
    */
} //이 스코프가 종료되고, hello는 더 이상 유효하지 않는다.
// 러스트는 변수가 스코프 밖으로 벗어나면 drop이라는 특별한 함수를 호출한다. 이 함수는 해당 타입을 개발한 개발자가 직접 메모리 해제 코드를 작성해 넣을 수 있게 되어있고,
// 위의 경우 String 개발자가 작성한 메모리 해제 코드가 실행된다. (drop은 닫힌 중괄호가 나타나는 지점에서 자동으로 호출)