#######20250725###########
rust에서 변수는 불변 그러므로 변수 설정 시 가변일 경우 mut를 입력 해야됨 / rust는 이전의 있던 변수의 값을 가리는 것을 허용한다.(shadow)
    -> 러스트가 제공하는 안정성과 쉬운 동시성을 활용하는 방식으로 코드를 작성할 수 있도록 하는 넛지 (nudge, 슬며시 선택을 유도하기) 중 하나입니다
    -> 같은 변수명을 사용 할려면 let 키워드를 반복하여 변수를 가릴 수 있다. -> 같은 변수명으로 다른 타입의 값을 저장 할 수 있다.
rust는 코드의 불필요한 부분을 줄이고, 실수로 사용하지 않은 변수를 미리 경고해주는 안전한 언어이기 때문에 이런 경고를 기본값으로 제공한다. 
    -> 만약 의도적으로 변수를 사용하지 않을 계획이라면, 변수 이름 앞에 언더스코어(_)를 붙이면 이 변수는 사용하지 않아도 경고가 뜨지 않는다.

io::stdin().read_line : 표준 입력(콘솔, 즉 터미널)에서 한 줄의 입력을 읽어들이는 함수로, 입력값을 지정한 가변 String 변수에 저장한다

#######20250730###########
1. rust는 강한 정적 타입 시스템을 가진다 / 표현식 기반의 언어 -> 표현식과 구문의 구분을 잘 해야한다.
    -> 구문은 어떤 동작을 수행하고 값을 반환하지 않는 명령이다.
    -> 표현식은 결괏값을 평가한다. -> 표현식에 ;(세미콜론)을 입력 시 표현식에서 구문으로 변경되어서 값을 반환하지 않는다.

2. rust는 함수나 변수 이름을 관례로 스네이크 케이스를 사용한다. -> 모든 글자를 소문자로 쓰고 단어구분을 _(밑줄)로 한다.

3. rust에서 함수 시그니처에서 매개변수의 타입을 무조건 설정을 해야한다.
    -> 함수의 정의에 타입 명시를 강제하면 이 함수를 다른 코드에서 사용할 때 여러분이 의도한 타입을 컴파일러가 추측하지 않아도 되게 된다. 
    -> 컴파일러는 또한 함수가 기대한 타입이 무엇인지 알고 있으면 더욱 유용한 에러 메시지를 제공할 수 있습니다.

4. rust는 boolean 타입이 아닌 값을 boolean 타입으로 자동변환을 안한다.

########20250808############
1. 소유권은 러스트 프로그램의 메모리 관리법을 지배하는 규칙 모음 (몇몇 언어는 가비지 컬렉션으로 관리 또는 프로그래머가 직접 명시적으로 메모리를 할당하고 해제하는 방식을 채용)
    -> 반면 러스트는 소유권(ownership)이라는 시스템을 만들고, 컴파일러가 컴파일 중에 검사할 여러 '규칙'을 정해 메모리를 관리하는 방식을 채용
    -> 이 '규칙'을 하나라도 위반하면 프로그램은 컴파일되지 않는다. 소유권의 어떠한 특성도 프로그램 실행 속도를 느리게 하지 않는다.
    -> 러스트는 값을 '스택', '힙'에 저장하느냐에 따라 프러그램의 동작 및 플그래머의 의사결정에 훨씬 큰 영향을 미친다.
2. 스택 : 후입선출, 데이터 추가하는 행위 (push), 데이터를 제거하는 행위 (pop) / 스택에 저장되는 데이터는 모두 명확하고 크기가 정해져 있어야 한다.
   힙 : 컴파일 타입에 크기를 알수 없거나, 크기가 변경될 수 있는 데이터 저장 / 데이터 저장 시 먼저 저장할 공간이 있는지 운영체제가 물어본다.
    힙 영역 안에서 어떤 빈 지점을 찾고 이 지점은 사용 중이라고 표시한 뒤 해당 지점을 가리키는 포인터(pointer)를 우리한테 반환한다. (힙 공간 할당-allocation on the heap) 줄여서 할당(allocation)
3. 스택 영역은 데이터 접근하는 방식상 힙 영역보다 속도가 빠르다.
   코드 어느 부분에서 힙의 어떤 데이터를 사용하는지 추적하고, 힙에서 중복되는 데이터를 최소화하고, 쓰지 않는 데이터를 힙에서 정리해 영역을 확보하는 등의 작업은 모두 '소유권'과 관려되어 있다.
4. 소유권 규칙 : 러스트에서, 각각의 값은 소유자(owner)가 정해져 있다. 
              한 값의 소유자는 동시에 여럿 조재할 수 없다.
              소유자가 스코프 밖으로 벗어날 때, 값은 버려진다(dropped)
5. 변수의 스코프(scope) : 프로그램 내에서 아이템이 유효한 범위
6. 참조자(reference) : 해당 주소에 저장된 데이터에 접근할 수 있도록 해주는 주솟값에 해당하는, 포인터와 같은 것이다. / 살아있는 동안 특정 타입에 대한 유효한 값을 가리킴을 보장해 준다.
7. 데이터 경합 : 다음 세가지 상황이 겹칠 때 일어나는 특정한 경합 조건(race condition)이다.
        -> 둘 이상의 포인터가 동시에 같은 데이터에 접근 / 포인터 중 하나 이상이 데이터에 쓰기 작업을 시행 / 데이터 접근 동기화 메커니즘이 없음
8. 댕글링 포인터(dongling pointer) : 어떤 메모리를 가리키는 포인터가 남아있는 상황에서 일부 메모리를 해제해 버림으로써 다른 개체가 할당 받았을지도 모르는 메모리를 참조하게 된 포인터

##########20250811###############
1. 슬라이스(slice) : 컬렉션(collection)을 통째로 참조하는 것이 아닌, 컬렉션의 연속된 일련의 요소를 참조하도록 한다. 참조자의 일종으로서 소유권을 갖지 않는다.
2. 문자열 슬라이스(string slice) : String의 일부를 가리키는 참조자