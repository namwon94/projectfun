#######20250725###########
rust에서 변수는 불변 그러므로 변수 설정 시 가변일 경우 mut를 입력 해야됨 / rust는 이전의 있던 변수의 값을 가리는 것을 허용한다.(shadow)
    -> 러스트가 제공하는 안정성과 쉬운 동시성을 활용하는 방식으로 코드를 작성할 수 있도록 하는 넛지 (nudge, 슬며시 선택을 유도하기) 중 하나입니다
    -> 같은 변수명을 사용 할려면 let 키워드를 반복하여 변수를 가릴 수 있다. -> 같은 변수명으로 다른 타입의 값을 저장 할 수 있다.
rust는 코드의 불필요한 부분을 줄이고, 실수로 사용하지 않은 변수를 미리 경고해주는 안전한 언어이기 때문에 이런 경고를 기본값으로 제공한다. 
    -> 만약 의도적으로 변수를 사용하지 않을 계획이라면, 변수 이름 앞에 언더스코어(_)를 붙이면 이 변수는 사용하지 않아도 경고가 뜨지 않는다.

io::stdin().read_line : 표준 입력(콘솔, 즉 터미널)에서 한 줄의 입력을 읽어들이는 함수로, 입력값을 지정한 가변 String 변수에 저장한다

#######20250730###########
1. rust는 강한 정적 타입 시스템을 가진다 / 표현식 기반의 언어 -> 표현식과 구문의 구분을 잘 해야한다.
    -> 구문은 어떤 동작을 수행하고 값을 반환하지 않는 명령이다.
    -> 표현식은 결괏값을 평가한다. -> 표현식에 ;(세미콜론)을 입력 시 표현식에서 구문으로 변경되어서 값을 반환하지 않는다.

2. rust는 함수나 변수 이름을 관례로 스네이크 케이스를 사용한다. -> 모든 글자를 소문자로 쓰고 단어구분을 _(밑줄)로 한다.

3. rust에서 함수 시그니처에서 매개변수의 타입을 무조건 설정을 해야한다.
    -> 함수의 정의에 타입 명시를 강제하면 이 함수를 다른 코드에서 사용할 때 여러분이 의도한 타입을 컴파일러가 추측하지 않아도 되게 된다. 
    -> 컴파일러는 또한 함수가 기대한 타입이 무엇인지 알고 있으면 더욱 유용한 에러 메시지를 제공할 수 있습니다.

4. rust는 boolean 타입이 아닌 값을 boolean 타입으로 자동변환을 안한다.

########20250808############
1. 소유권은 러스트 프로그램의 메모리 관리법을 지배하는 규칙 모음 (몇몇 언어는 가비지 컬렉션으로 관리 또는 프로그래머가 직접 명시적으로 메모리를 할당하고 해제하는 방식을 채용)
    -> 반면 러스트는 소유권(ownership)이라는 시스템을 만들고, 컴파일러가 컴파일 중에 검사할 여러 '규칙'을 정해 메모리를 관리하는 방식을 채용
    -> 이 '규칙'을 하나라도 위반하면 프로그램은 컴파일되지 않는다. 소유권의 어떠한 특성도 프로그램 실행 속도를 느리게 하지 않는다.
    -> 러스트는 값을 '스택', '힙'에 저장하느냐에 따라 프러그램의 동작 및 플그래머의 의사결정에 훨씬 큰 영향을 미친다.
2. 스택 : 후입선출, 데이터 추가하는 행위 (push), 데이터를 제거하는 행위 (pop) / 스택에 저장되는 데이터는 모두 명확하고 크기가 정해져 있어야 한다.
   힙 : 컴파일 타입에 크기를 알수 없거나, 크기가 변경될 수 있는 데이터 저장 / 데이터 저장 시 먼저 저장할 공간이 있는지 운영체제가 물어본다.
    힙 영역 안에서 어떤 빈 지점을 찾고 이 지점은 사용 중이라고 표시한 뒤 해당 지점을 가리키는 포인터(pointer)를 우리한테 반환한다. (힙 공간 할당-allocation on the heap) 줄여서 할당(allocation)
3. 스택 영역은 데이터 접근하는 방식상 힙 영역보다 속도가 빠르다.
   코드 어느 부분에서 힙의 어떤 데이터를 사용하는지 추적하고, 힙에서 중복되는 데이터를 최소화하고, 쓰지 않는 데이터를 힙에서 정리해 영역을 확보하는 등의 작업은 모두 '소유권'과 관려되어 있다.
4. 소유권 규칙 : 러스트에서, 각각의 값은 소유자(owner)가 정해져 있다. 
              한 값의 소유자는 동시에 여럿 조재할 수 없다.
              소유자가 스코프 밖으로 벗어날 때, 값은 버려진다(dropped)
5. 변수의 스코프(scope) : 프로그램 내에서 아이템이 유효한 범위
6. 참조자(reference) : 해당 주소에 저장된 데이터에 접근할 수 있도록 해주는 주솟값에 해당하는, 포인터와 같은 것이다. / 살아있는 동안 특정 타입에 대한 유효한 값을 가리킴을 보장해 준다.
7. 데이터 경합 : 다음 세가지 상황이 겹칠 때 일어나는 특정한 경합 조건(race condition)이다.
        -> 둘 이상의 포인터가 동시에 같은 데이터에 접근 / 포인터 중 하나 이상이 데이터에 쓰기 작업을 시행 / 데이터 접근 동기화 메커니즘이 없음
8. 댕글링 포인터(dongling pointer) : 어떤 메모리를 가리키는 포인터가 남아있는 상황에서 일부 메모리를 해제해 버림으로써 다른 개체가 할당 받았을지도 모르는 메모리를 참조하게 된 포인터

##########20250811###############
1. 슬라이스(slice) : 컬렉션(collection)을 통째로 참조하는 것이 아닌, 컬렉션의 연속된 일련의 요소를 참조하도록 한다. 참조자의 일종으로서 소유권을 갖지 않는다.
2. 문자열 슬라이스(string slice) : String의 일부를 가리키는 참조자

##########320250812##############
1. 구조체 : 여러 개의 연관된 값을 가질 수 있다는 측면에서 볼 때 튜플과 비슷하다. 튜플 처럼 구조체의 구성 요소들은 각각 다른 타입이 될 수 있다
    -> 구조체를 정의하려면 struct 키워드와 해당 구조체에 지어줄 이름을 입력한다, 이때 구조체 이름은 함께 묶을 데이터의 의미에 맞도록 지어야 한다. 
    -> 중괄호 안에서는 필드(field)라고 부르는 각 구성 요소의 이름 및 타입을 정의한다.
    -> 가변성은 해당 인스턴스 전체가 지니게 된다. 일부 필드만 가변으로 만들 수는 없다.
    -> 참조자를 이용해 구조체가 소유권을 갖지 않는 데이터도 저장 가능하지만 '라이프타임(lifetime)'을 활용해야 한다.
    -> 구조체를 사용하면 도메인에 의미 있는 커스텀 타입을 만들 수 있다.
2. 튜플 구조체 : 구조체 자체에는 이름을 지어 의미를 주지만 이를 구성하는 필드에는 이름을 붙이지 않고 타입만 적어 넣는 형태
    -> 튜플 전체에 이름을 지어주거나 특정 튜플을 다른 튜플과 구분하고는 싶지만 각 필드명을 일일이 정해 일반적인 구조체 형태로 만들면 너무 장황하거나 불필요할 경우 유용
3. 유사 유닛 구조체(unit-like structs) : 필드가 아예 없는 구조체 / 어떤 타입에 대해 트레이트를 구현하고 싶지만 타입 내부에 어떤 데이터를 저장할 필요는 없을 경우 유용 (AlwaysEqual 라는 이름으로 선언)
4. 구조체는 중간중간 쉼표를 사용해야 할 수도 있고, 중괄호도 출력해야 할 수도 있도, 필드 일부를 생략해야 할 수도 있는 등 여러가지가 가능하다. 
    그래서 러스트는 이런 애매한 상황에 우리가 원하는 걸 임의로 예상해서 제고하려 들지 않기 때문에, 구조체에는 println! 및 {} 자리표시자와 함께 사용하기 위한 Display 구현체가 기본 제공되지 않는다.
    {} 내에 :?를 추가하는 건 println!에 Debug라는 출력 형식을 사용하고 싶다고 전달하는 것과 같다.
    러스트는 디버깅 정보를 출력하는 기능을 자체적으로 가지고 있지만 우리가 만든 구조체에 해당 기능을 적용하려면 명시적인 동의가 필요하다. -> #[derive(Debug)] 외부 속성을 작성해야됨

#######20250813#################
1. 동적 계획법(메모이제이션) : 재귀 함수를 효율적으로 만들어주는 기법이다. 이미 계산한 값을 저장해 두어 동일한 계산을 반복하지 않도록 하는 방식이다. 
    -> 피보나치 수열 같은 문제에서 중복 재귀 호출을 방지해 속도를 크게 개선할 수 있다.

########20250814###############
1. 메서드(method) : 함수와 유사. fn 키워드와 함수명으로 선언하고, 매개변수와 반환 값을 가지며, 다른 어딘가로부터 호출될 때 실행된다. 
    -> 하지만 함수와 달리 구조체 컨텍스트에 정의되고 (열거형이나 트레이트 객체 안에서 정의 되기도함) 첫 번째 매개변수가 항상 self라느 차이점이 있다.
    -> 메서드 문법은 차례대로 인스턴스, 점, 메서드명, 괄호 및 인수로 구성
2. 함수 대신 메서드를 사용하는 주된 이유 : 메서드 구문을 제공하고 모든 메서드 시그네처 내에서 self 타입을 반복할 필요가 없다는 것 외에도 코드를 더 조직적으로 만들기 위해서 이다.
    -> 향후 우리가 제공하는 라이브러리를 사용하는 사람들이 우리가 만든 기능과 관련된 코드를 라이브러리 곳곳에서 찾아내야 하는 것보다는 하나의 impl블록 내에 이 타입의 인스턴스로 할 수 있는 모든 것들을 모아두는 것
3. 러스트는 구조체 필드에 대한 게터(getter)를 자동으로 만들지 않는다. -> 필드를 비공개(private) 메서드는 공개(public)로 만들 수 있다.
    -> 게터는 어떤 타입의 공개 API로써 어떤 필드에 대해 읽기 전용 접근만 허용하고자 하는 경우 유용하다.
4. 러스트에 -> 연산자는 없다. -> 러스트에는 자동 참조 및 역참조라는 기능이 있고, 메서드 호출에 이 기능이 포함되어 있기 떄문이다.
    (C 나 C++언어에서는 메서드 호출에 사용하는 연산자)
5. 열거형 : 어떤 값이 여러 개의 가능한 값(variant)의 집합 중 하나라는 것을 나타내는 방법을 제공한다. ex) Rectangle이 Circle과 Triangel을 포함하는 다양한 모양들의 집합 중 하나라고 표현하고 싶을 수 있다.
6. Option<T> : 러스트에는 널(null) 개념이 없다. 하지만 값의 존재 혹은 부재의 개념을 표현할 수 있는 열거형이 바로 Option<T>이다.