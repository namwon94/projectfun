#######20250725###########
rust에서 변수는 불변 그러므로 변수 설정 시 가변일 경우 mut를 입력 해야됨 / rust는 이전의 있던 변수의 값을 가리는 것을 허용한다.(shadow)
    -> 러스트가 제공하는 안정성과 쉬운 동시성을 활용하는 방식으로 코드를 작성할 수 있도록 하는 넛지 (nudge, 슬며시 선택을 유도하기) 중 하나입니다
    -> 같은 변수명을 사용 할려면 let 키워드를 반복하여 변수를 가릴 수 있다. -> 같은 변수명으로 다른 타입의 값을 저장 할 수 있다.
rust는 코드의 불필요한 부분을 줄이고, 실수로 사용하지 않은 변수를 미리 경고해주는 안전한 언어이기 때문에 이런 경고를 기본값으로 제공한다. 
    -> 만약 의도적으로 변수를 사용하지 않을 계획이라면, 변수 이름 앞에 언더스코어(_)를 붙이면 이 변수는 사용하지 않아도 경고가 뜨지 않는다.

io::stdin().read_line : 표준 입력(콘솔, 즉 터미널)에서 한 줄의 입력을 읽어들이는 함수로, 입력값을 지정한 가변 String 변수에 저장한다

#######20250730###########
1. rust는 강한 정적 타입 시스템을 가진다 / 표현식 기반의 언어 -> 표현식과 구문의 구분을 잘 해야한다.
    -> 구문은 어떤 동작을 수행하고 값을 반환하지 않는 명령이다.
    -> 표현식은 결괏값을 평가한다. -> 표현식에 ;(세미콜론)을 입력 시 표현식에서 구문으로 변경되어서 값을 반환하지 않는다.

2. rust는 함수나 변수 이름을 관례로 스네이크 케이스를 사용한다. -> 모든 글자를 소문자로 쓰고 단어구분을 _(밑줄)로 한다.

3. rust에서 함수 시그니처에서 매개변수의 타입을 무조건 설정을 해야한다.
    -> 함수의 정의에 타입 명시를 강제하면 이 함수를 다른 코드에서 사용할 때 여러분이 의도한 타입을 컴파일러가 추측하지 않아도 되게 된다. 
    -> 컴파일러는 또한 함수가 기대한 타입이 무엇인지 알고 있으면 더욱 유용한 에러 메시지를 제공할 수 있습니다.

4. rust는 boolean 타입이 아닌 값을 boolean 타입으로 자동변환을 안한다.

########20250808############
1. 소유권은 러스트 프로그램의 메모리 관리법을 지배하는 규칙 모음 (몇몇 언어는 가비지 컬렉션으로 관리 또는 프로그래머가 직접 명시적으로 메모리를 할당하고 해제하는 방식을 채용)
    -> 반면 러스트는 소유권(ownership)이라는 시스템을 만들고, 컴파일러가 컴파일 중에 검사할 여러 '규칙'을 정해 메모리를 관리하는 방식을 채용
    -> 이 '규칙'을 하나라도 위반하면 프로그램은 컴파일되지 않는다. 소유권의 어떠한 특성도 프로그램 실행 속도를 느리게 하지 않는다.
    -> 러스트는 값을 '스택', '힙'에 저장하느냐에 따라 프러그램의 동작 및 플그래머의 의사결정에 훨씬 큰 영향을 미친다.
2. 스택 : 후입선출, 데이터 추가하는 행위 (push), 데이터를 제거하는 행위 (pop) / 스택에 저장되는 데이터는 모두 명확하고 크기가 정해져 있어야 한다.
   힙 : 컴파일 타입에 크기를 알수 없거나, 크기가 변경될 수 있는 데이터 저장 / 데이터 저장 시 먼저 저장할 공간이 있는지 운영체제가 물어본다.
    힙 영역 안에서 어떤 빈 지점을 찾고 이 지점은 사용 중이라고 표시한 뒤 해당 지점을 가리키는 포인터(pointer)를 우리한테 반환한다. (힙 공간 할당-allocation on the heap) 줄여서 할당(allocation)
3. 스택 영역은 데이터 접근하는 방식상 힙 영역보다 속도가 빠르다.
   코드 어느 부분에서 힙의 어떤 데이터를 사용하는지 추적하고, 힙에서 중복되는 데이터를 최소화하고, 쓰지 않는 데이터를 힙에서 정리해 영역을 확보하는 등의 작업은 모두 '소유권'과 관려되어 있다.
4. 소유권 규칙 : 러스트에서, 각각의 값은 소유자(owner)가 정해져 있다. 
              한 값의 소유자는 동시에 여럿 조재할 수 없다.
              소유자가 스코프 밖으로 벗어날 때, 값은 버려진다(dropped)
5. 변수의 스코프(scope) : 프로그램 내에서 아이템이 유효한 범위
6. 참조자(reference) : 해당 주소에 저장된 데이터에 접근할 수 있도록 해주는 주솟값에 해당하는, 포인터와 같은 것이다. / 살아있는 동안 특정 타입에 대한 유효한 값을 가리킴을 보장해 준다.
7. 데이터 경합 : 다음 세가지 상황이 겹칠 때 일어나는 특정한 경합 조건(race condition)이다.
        -> 둘 이상의 포인터가 동시에 같은 데이터에 접근 / 포인터 중 하나 이상이 데이터에 쓰기 작업을 시행 / 데이터 접근 동기화 메커니즘이 없음
8. 댕글링 포인터(dongling pointer) : 어떤 메모리를 가리키는 포인터가 남아있는 상황에서 일부 메모리를 해제해 버림으로써 다른 개체가 할당 받았을지도 모르는 메모리를 참조하게 된 포인터

##########20250811###############
1. 슬라이스(slice) : 컬렉션(collection)을 통째로 참조하는 것이 아닌, 컬렉션의 연속된 일련의 요소를 참조하도록 한다. 참조자의 일종으로서 소유권을 갖지 않는다.
2. 문자열 슬라이스(string slice) : String의 일부를 가리키는 참조자

##########320250812##############
1. 구조체 : 여러 개의 연관된 값을 가질 수 있다는 측면에서 볼 때 튜플과 비슷하다. 튜플 처럼 구조체의 구성 요소들은 각각 다른 타입이 될 수 있다
    -> 구조체를 정의하려면 struct 키워드와 해당 구조체에 지어줄 이름을 입력한다, 이때 구조체 이름은 함께 묶을 데이터의 의미에 맞도록 지어야 한다. 
    -> 중괄호 안에서는 필드(field)라고 부르는 각 구성 요소의 이름 및 타입을 정의한다.
    -> 가변성은 해당 인스턴스 전체가 지니게 된다. 일부 필드만 가변으로 만들 수는 없다.
    -> 참조자를 이용해 구조체가 소유권을 갖지 않는 데이터도 저장 가능하지만 '라이프타임(lifetime)'을 활용해야 한다.
    -> 구조체를 사용하면 도메인에 의미 있는 커스텀 타입을 만들 수 있다.
2. 튜플 구조체 : 구조체 자체에는 이름을 지어 의미를 주지만 이를 구성하는 필드에는 이름을 붙이지 않고 타입만 적어 넣는 형태
    -> 튜플 전체에 이름을 지어주거나 특정 튜플을 다른 튜플과 구분하고는 싶지만 각 필드명을 일일이 정해 일반적인 구조체 형태로 만들면 너무 장황하거나 불필요할 경우 유용
3. 유사 유닛 구조체(unit-like structs) : 필드가 아예 없는 구조체 / 어떤 타입에 대해 트레이트를 구현하고 싶지만 타입 내부에 어떤 데이터를 저장할 필요는 없을 경우 유용 (AlwaysEqual 라는 이름으로 선언)
4. 구조체는 중간중간 쉼표를 사용해야 할 수도 있고, 중괄호도 출력해야 할 수도 있도, 필드 일부를 생략해야 할 수도 있는 등 여러가지가 가능하다. 
    그래서 러스트는 이런 애매한 상황에 우리가 원하는 걸 임의로 예상해서 제고하려 들지 않기 때문에, 구조체에는 println! 및 {} 자리표시자와 함께 사용하기 위한 Display 구현체가 기본 제공되지 않는다.
    {} 내에 :?를 추가하는 건 println!에 Debug라는 출력 형식을 사용하고 싶다고 전달하는 것과 같다.
    러스트는 디버깅 정보를 출력하는 기능을 자체적으로 가지고 있지만 우리가 만든 구조체에 해당 기능을 적용하려면 명시적인 동의가 필요하다. -> #[derive(Debug)] 외부 속성을 작성해야됨

#######20250813#################
1. 동적 계획법(메모이제이션) : 재귀 함수를 효율적으로 만들어주는 기법이다. 이미 계산한 값을 저장해 두어 동일한 계산을 반복하지 않도록 하는 방식이다. 
    -> 피보나치 수열 같은 문제에서 중복 재귀 호출을 방지해 속도를 크게 개선할 수 있다.

########20250814###############
1. 메서드(method) : 함수와 유사. fn 키워드와 함수명으로 선언하고, 매개변수와 반환 값을 가지며, 다른 어딘가로부터 호출될 때 실행된다. 
    -> 하지만 함수와 달리 구조체 컨텍스트에 정의되고 (열거형이나 트레이트 객체 안에서 정의 되기도함) 첫 번째 매개변수가 항상 self라는 차이점이 있다.
    -> 메서드 문법은 차례대로 인스턴스, 점, 메서드명, 괄호 및 인수로 구성
2. 함수 대신 메서드를 사용하는 주된 이유 : 메서드 구문을 제공하고 모든 메서드 시그네처 내에서 self 타입을 반복할 필요가 없다는 것 외에도 코드를 더 조직적으로 만들기 위해서 이다.
    -> 향후 우리가 제공하는 라이브러리를 사용하는 사람들이 우리가 만든 기능과 관련된 코드를 라이브러리 곳곳에서 찾아내야 하는 것보다는 하나의 impl블록 내에 이 타입의 인스턴스로 할 수 있는 모든 것들을 모아두는 것
3. 러스트는 구조체 필드에 대한 게터(getter)를 자동으로 만들지 않는다. -> 필드를 비공개(private) 메서드는 공개(public)로 만들 수 있다.
    -> 게터는 어떤 타입의 공개 API로써 어떤 필드에 대해 읽기 전용 접근만 허용하고자 하는 경우 유용하다.
4. 러스트에 -> 연산자는 없다. -> 러스트에는 자동 참조 및 역참조라는 기능이 있고, 메서드 호출에 이 기능이 포함되어 있기 떄문이다.
    (C 나 C++언어에서는 메서드 호출에 사용하는 연산자)
5. 열거형 : 어떤 값이 여러 개의 가능한 값(variant)의 집합 중 하나라는 것을 나타내는 방법을 제공한다. ex) Rectangle이 Circle과 Triangel을 포함하는 다양한 모양들의 집합 중 하나라고 표현하고 싶을 수 있다.
6. Option<T> : 러스트에는 널(null) 개념이 없다. 하지만 값의 존재 혹은 부재의 개념을 표현할 수 있는 열거형이 바로 Option<T>이다.

########20250816#############
1. match : 매우 강려한 제어 흐름 연산자 / 일련의 패텀에 대해 어떤 값을 비교한 뒤 어떤 패턴에 매치되었는지를 바탕을 코드를 수행하도록 도와준다.
    -> 패턴은 리터럴 값, 변수명, 와일드카드 등 다양한 것으로 구성될 수 있다.
    -> match의 힘은 패턴의 표현성으로부터 오며 컴파일러는 모든 가능한 경우가 처리되는지 검사한다.
    -> match의 표현식은 동전분류기를 생각해보면 된다. 동전들의 다양한 크기의 구멍들이 있는 트랙으로 동전이 떨어지고 각기 맞는 크기별로 동전이 들어가는 방식
    -> match의 표현식이 실행될 때, 결과값을 각 갈래의 패턴에 대해서 순차적으로 비교한다.
2. 포과 패턴(catch-all) : 특별하게 나열되지 않은 나머지 모든 값에 대해 마지막 패턴이 매칭되는 패턴
    -> 패턴들은 순차적으로 평가되므로 마지막에 포괄적인 갈래를 위치시켜야 한다 / 포괄적인 갈래를 이보다 앞에 두면 그 뒤에 있는 갈래를 결코 실행될 수 없다.
    -> 만약 포괄 패턴 뒤에 갈래를 추가하면 러스트는 이에 대해 경고를 준다.
    -> other 혹은 _ 를 사용한다.

########20250818###############
1. if let : if와 let을 조합하여 하나의 패턴만 매칭시키고 나머지 경우는 무시하도록 값을 처리하는 간결한 방법 제공
    -> if let은 '='로 구분된 패턴과 표현식을 입력받는다. / 보일러 플레이트 코드를 덜 쓰게 된다.
        -> match가 강제했던 철저한 검사를 안하게 된다. -> if let은 한 패턴에 매칭될 때만 코드를 실행하고 다른 경우는 무시하는 match문을 작성할 때 사용하는 '문법 설당' 이다.
    -> else도 사용가능하다.
2. 열거형 값에 데이터가 있는 경우 처리해야 하는 경우의 수에따라 match나 if let을 사용하여 해당 값을 추출하여 사용할 수 있다.
3. 프로젝트를 패키지, 크레이트, 모듈로 관리하기
    -> 프로젝트 규모가 커지면 코드를 여러 모듈, 여러 파일로 나누어 관리해야 한다. 한 패키지에는 여러 개의 바이너리 크레이트와 (원할경우) 라이브러리 크레이트가 포함될 수 있으므로,
        커진 프로젝트의 각 부분을 크레이트로 나눠서 외부 라이브러리처럼 쓸 수 있다.
    -> 세부 구현을 캡슐화하면 더 고수준에서 코드를 재사용할 수 있는 방법에 대해서도 설명한다. 일단 어떤 연산을 구현하면 그 구현체의 작동 방식을 몰라도 다른 코드에서 공개 인터페이스를 통해 
        해당 코드를 호출할 수 있다, 코드를 작성하는 방식에 따라 다른 코드가 사용할 수 잇는 공개 부분과 변경 권한을 작성자에게 남겨두는 비공개 구현 세부 사항이 정의된다.
        (스코드 개념도 관련됨)
    -> 러스트에는 코드 조직화에 필요한 기능이 여럿 있다. 어떤 세부 정보를 외부에 노출할지, 비공개로 둘지, 프로그램의 스코프 내 어떤 이름이 있는지 등 다양하다 이를 '모듈 시스템' 이라고 함.
        -> 패키지 : 크레이트를 빌드하고, 테스트하고, 공유하는 데 사용하는 카고 기능이다. / 일련의 기능을 제공하는 하나 이상의 크레이트로 구성된 번들
            -> 패키지에는 이 크레이트들을 빌드하는 법이 설명된 Cargo.toml이 포함되어 있다. 카고는 실제로 코드를 빌드하는 데 사용하는 커맨드 라인 도구의 '바이너리 크레이트'가 포함된 패키지
            -> 패키지에는 여러 개의 바이너리 크레이트가 원하는 만큼 포함될 수 있지만, 라이브러리 크레이트는 하나만 넣을 수 있다.
            -> 패키지에는 적어도 하나 이상의 크레이트가 포함되어야 하며, 이는 라이브러리든 바이너리든 상관없다.
        -> 크레이트 : 라이브러리(바이너리도 됨)나 실행 가능한 모듈로 구성된 트리 구조이다. / 러스트가 컴파일 한 차례에 고려하는 가장 작은 코드 단위 / 여러 모듈을 담을 수 있음
            / 모듈은 이 크레이트와 함께 컴파일되는 다른 파일들에 정의되어 있을 수도 있다. 
            -> 바이너리 크레이드 : 커맨드 라인 프로그램이나 서버처럼 실행 가능한 실행파일로 컴파일할 수 있는 프로그램(main 함수 포함)
            -> 라이브러리 크레이트 : main함수 가지고 있지 않고 실행파일 형태로 컴파일되지 않음 / 여러 프로젝트에서 공용될 의도로 만들어진 기능들이 정의됨
                / 보톤 러스타시안들이 '크레이트'라고 말하면 대부분은 이 라이브러리 크레이트를 의미한다. 일반적인 프로그래밍 개념에서의 '라이브러리'와 혼용됨.
            -> 크레이트 루트 : 러스트 컴파일러가 컴파일을 시작하는 소스 파일이고, 크레이트의 루트 모듈을 구성한다 
        -> 모듈 과 use : 구조, 스코프를 제어하고, 조직 세부 경로를 감추는 데 사용한다.
            -> 크레이트 루트부터 시작 : 크레이트를 컴파일할 때 컴파일러는 먼저 크레이트 루트 파일을 본다.(보통 라이브러리 크레이트는 lib.rs를 바이너리 크레이트는 main.rs이다)
            -> 모듈 선언 : 크레이트 루프 파일에는 새로운 모듈을 선언할 수 있다. 
                ex. mod garden; 이라킄 코드로 garden 모듈을 선언할 수 있다. 
            -> 모둘 내 코들로의 경로 : 일단 모듈이 크레이트의 일부로서 구성되면, 공개 규칙이 허용하는 한도 내에서라면 해당 코드의 경로를 사용하여 동일한 크레이트의 어디에서든 이 모듈의 코드를 참조할 수 있음
            -> 비공개 vs 공개 : 모둘 내의 코드는 기본적으로 부모 모듈에게 비공개(private)이다. 모듈은 공개(public)로 만들려면, mod 대신 pub mod를 써서 선언해야됨.
            -> use 키워드 : 어떤 스코프 내에서 use 키워드는 긴 경로의 반복을 불이기 위한 어떤 아이템으로의 단축경로를 만들어 준다.
                -> use키워드와 경로를 작성하는 건 파일 시스템에서 심볼릭 링크(sysbolic link)를 생성하는 것과 유사하다.
        -> 경로 : 구조체, 함수, 모듈 등의 이름을 지정한다.
            -> 절대 경로(absolute path) : 크레이트 루트로부터 시작되는 전체 경로이다. 외부 크레이트로부터의 코드에 대해서는 해당 크레이트 이름으로 절대 경로가 시작되고 현재의 크레이트로부터의 코드에 대해서는
                'crate'리터럴로 부터 시작된다.
            -> 상대 경로(relative path) : 현재의 모듈을 시작점으로 하여 self, super 혹은 모듈 내의 식별자를 사용한다.
            -> 절대 경로, 상대경로 뒤에는 '::'으로 구분된 식별자가 하나 이상 따라온다.

############20250820#############
1. 러스트에서는 (함수, 메서드, 구조체, 열거형, 모듈, 상수) 모든 아이템이 기본적으로 부모 모듈에 대해 비공개이다.
    -> 부모 모듈 내 아이템은 자식 모듈 내 비공개 아이템을 사용할 수 없지만, 자식 모듈 내 아이템은 부모 모듈 내 아이템을 사용할 수 있다.
        -> 자식 모듈의 세부 구현은 감싸져서 숨겨져 있지만, 자식 모듈 내에서는 자신이 정의된 컨텍스트를 볼 수 있기 때문이다. 
2. 구조체 정의에 pub를 쓰면 구조체는 공개되지만, 구조체의 필드는 비공개로 유지된다. 공개여부는 각 필드마다 정할 수 있다. -> 구조체 필드는 공개로 하지 않는 것이 종종 유용하므로 pub을 명시하지 않는 한 기본적으로 비공개
3. 열거형은 공개로 지정할 경우 모든 배리언트가 공개된다. -> 열겨형은 그 배리언트가 공개되지 않는다면 큰 쓸모가 없다. 
    -> 열거형의 모든 배리언트에 대해 전부 pub를 붙이는 것은 귀찮은 일이 될 것이므로, 열거형의 배리언트는 기본적으로 공개이다.

##########20250821###############
1. 컬렉션(collection) : 다수의 값을 담을 수 있다. 내장된 배열(build in arrray) 이나 튜플과 달리 컬렉션들이 가리키는 데이터는 '힙'에 저장된다.
    -> 힙에 저장되는 의미 : 데이터의 양이 컴파일 타임에 결정되지 않아도 되며 프로그램 실행 중에 늘어나거나 줄어들수 있다.
    -> 각 컬렉션 종류는 서로 다른 크기와 비용을 가지고 있다.
2. 벡터(vector) : 여러 개의 값을 서로 붙어 있게 저장할 수 있도록 해준다.(단일 데이터 구조) / 같은 타입의 값만을 저장할 수 있다. / 힙에 저장된다.
    -> 벡터는 제네릭(generic)을 이용하여 구현
    -> 열거형(다양한 타입의 배리언트)도 벡터로 담을 수 있다. -> 하나의 벡터의 한가지 벡터만 담을 수 있지만 열거형의 경우 모든 배리언트들은 해당 열거형 타입과 같은 타입으로 간주하기 때문이다.
        -> 만약 런타임에 프로그램이 벡터에 저장할 모든 타입 집합을 알지 못하면 열거형을 이용한 방식은 사용할 수 없다. 대신 '트레이트 객체(trait object)'를 이용할 수 있다.
    -> struct와 마찬가지로 벡터는 스코프를 벗어날 때 해제된다.
3. 문자열(string) : 문자(character)의 모음이다. / 바이트의 컬렉션으로 구현되어 있다. / 참조형인 &str형태로 사용하는 문자열 슬라이스 str이다.
    -> String타입은 언어의 핵심 기능에 구현된 것이 아니고 러스트의 표준 라이브러리를 통해 제공되며, 커질 수 있고, 가변적이며, 소유권을 갖고 있고, UTF-8으로 인코딩된 문자열 타입이다.
4. 해시맵(hashmap) : 어떤 값을 특정한 키와 연관지어 주도록 해분다. / 해시 함수(hashing function)을 사용하여 매핑한 것을 저장한다. / 힙에 저장된다.


