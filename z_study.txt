#######20250725###########
rust에서 변수는 불변 그러므로 변수 설정 시 가변일 경우 mut를 입력 해야됨 / rust는 이전의 있던 변수의 값을 가리는 것을 허용한다.(shadow)
    -> 러스트가 제공하는 안정성과 쉬운 동시성을 활용하는 방식으로 코드를 작성할 수 있도록 하는 넛지 (nudge, 슬며시 선택을 유도하기) 중 하나입니다
    -> 같은 변수명을 사용 할려면 let 키워드를 반복하여 변수를 가릴 수 있다. -> 같은 변수명으로 다른 타입의 값을 저장 할 수 있다.
rust는 코드의 불필요한 부분을 줄이고, 실수로 사용하지 않은 변수를 미리 경고해주는 안전한 언어이기 때문에 이런 경고를 기본값으로 제공한다. 
    -> 만약 의도적으로 변수를 사용하지 않을 계획이라면, 변수 이름 앞에 언더스코어(_)를 붙이면 이 변수는 사용하지 않아도 경고가 뜨지 않는다.

io::stdin().read_line : 표준 입력(콘솔, 즉 터미널)에서 한 줄의 입력을 읽어들이는 함수로, 입력값을 지정한 가변 String 변수에 저장한다

#######20250730###########
1. rust는 강한 정적 타입 시스템을 가진다 / 표현식 기반의 언어 -> 표현식과 구문의 구분을 잘 해야한다.
    -> 구문은 어떤 동작을 수행하고 값을 반환하지 않는 명령이다.
    -> 표현식은 결괏값을 평가한다. -> 표현식에 ;(세미콜론)을 입력 시 표현식에서 구문으로 변경되어서 값을 반환하지 않는다.

2. rust는 함수나 변수 이름을 관례로 스네이크 케이스를 사용한다. -> 모든 글자를 소문자로 쓰고 단어구분을 _(밑줄)로 한다.

3. rust에서 함수 시그니처에서 매개변수의 타입을 무조건 설정을 해야한다.
    -> 함수의 정의에 타입 명시를 강제하면 이 함수를 다른 코드에서 사용할 때 여러분이 의도한 타입을 컴파일러가 추측하지 않아도 되게 된다. 
    -> 컴파일러는 또한 함수가 기대한 타입이 무엇인지 알고 있으면 더욱 유용한 에러 메시지를 제공할 수 있습니다.

4. rust는 boolean 타입이 아닌 값을 boolean 타입으로 자동변환을 안한다.

########20250808############
1. 소유권은 러스트 프로그램의 메모리 관리법을 지배하는 규칙 모음 (몇몇 언어는 가비지 컬렉션으로 관리 또는 프로그래머가 직접 명시적으로 메모리를 할당하고 해제하는 방식을 채용)
    -> 반면 러스트는 소유권(ownership)이라는 시스템을 만들고, 컴파일러가 컴파일 중에 검사할 여러 '규칙'을 정해 메모리를 관리하는 방식을 채용
    -> 이 '규칙'을 하나라도 위반하면 프로그램은 컴파일되지 않는다. 소유권의 어떠한 특성도 프로그램 실행 속도를 느리게 하지 않는다.
    -> 러스트는 값을 '스택', '힙'에 저장하느냐에 따라 프러그램의 동작 및 플그래머의 의사결정에 훨씬 큰 영향을 미친다.
2. 스택 : 후입선출, 데이터 추가하는 행위 (push), 데이터를 제거하는 행위 (pop) / 스택에 저장되는 데이터는 모두 명확하고 크기가 정해져 있어야 한다.
   힙 : 컴파일 타입에 크기를 알수 없거나, 크기가 변경될 수 있는 데이터 저장 / 데이터 저장 시 먼저 저장할 공간이 있는지 운영체제가 물어본다.
    힙 영역 안에서 어떤 빈 지점을 찾고 이 지점은 사용 중이라고 표시한 뒤 해당 지점을 가리키는 포인터(pointer)를 우리한테 반환한다. (힙 공간 할당-allocation on the heap) 줄여서 할당(allocation)
3. 스택 영역은 데이터 접근하는 방식상 힙 영역보다 속도가 빠르다.
   코드 어느 부분에서 힙의 어떤 데이터를 사용하는지 추적하고, 힙에서 중복되는 데이터를 최소화하고, 쓰지 않는 데이터를 힙에서 정리해 영역을 확보하는 등의 작업은 모두 '소유권'과 관려되어 있다.
4. 소유권 규칙 : 러스트에서, 각각의 값은 소유자(owner)가 정해져 있다. 
              한 값의 소유자는 동시에 여럿 조재할 수 없다.
              소유자가 스코프 밖으로 벗어날 때, 값은 버려진다(dropped)
5. 변수의 스코프(scope) : 프로그램 내에서 아이템이 유효한 범위
6. 참조자(reference) : 해당 주소에 저장된 데이터에 접근할 수 있도록 해주는 주솟값에 해당하는, 포인터와 같은 것이다. / 살아있는 동안 특정 타입에 대한 유효한 값을 가리킴을 보장해 준다.
7. 데이터 경합 : 다음 세가지 상황이 겹칠 때 일어나는 특정한 경합 조건(race condition)이다.
        -> 둘 이상의 포인터가 동시에 같은 데이터에 접근 / 포인터 중 하나 이상이 데이터에 쓰기 작업을 시행 / 데이터 접근 동기화 메커니즘이 없음
8. 댕글링 포인터(dongling pointer) : 어떤 메모리를 가리키는 포인터가 남아있는 상황에서 일부 메모리를 해제해 버림으로써 다른 개체가 할당 받았을지도 모르는 메모리를 참조하게 된 포인터

##########20250811###############
1. 슬라이스(slice) : 컬렉션(collection)을 통째로 참조하는 것이 아닌, 컬렉션의 연속된 일련의 요소를 참조하도록 한다. 참조자의 일종으로서 소유권을 갖지 않는다.
2. 문자열 슬라이스(string slice) : String의 일부를 가리키는 참조자

##########320250812##############
1. 구조체 : 여러 개의 연관된 값을 가질 수 있다는 측면에서 볼 때 튜플과 비슷하다. 튜플 처럼 구조체의 구성 요소들은 각각 다른 타입이 될 수 있다
    -> 구조체를 정의하려면 struct 키워드와 해당 구조체에 지어줄 이름을 입력한다, 이때 구조체 이름은 함께 묶을 데이터의 의미에 맞도록 지어야 한다. 
    -> 중괄호 안에서는 필드(field)라고 부르는 각 구성 요소의 이름 및 타입을 정의한다.
    -> 가변성은 해당 인스턴스 전체가 지니게 된다. 일부 필드만 가변으로 만들 수는 없다.
    -> 참조자를 이용해 구조체가 소유권을 갖지 않는 데이터도 저장 가능하지만 '라이프타임(lifetime)'을 활용해야 한다.
    -> 구조체를 사용하면 도메인에 의미 있는 커스텀 타입을 만들 수 있다.
2. 튜플 구조체 : 구조체 자체에는 이름을 지어 의미를 주지만 이를 구성하는 필드에는 이름을 붙이지 않고 타입만 적어 넣는 형태
    -> 튜플 전체에 이름을 지어주거나 특정 튜플을 다른 튜플과 구분하고는 싶지만 각 필드명을 일일이 정해 일반적인 구조체 형태로 만들면 너무 장황하거나 불필요할 경우 유용
3. 유사 유닛 구조체(unit-like structs) : 필드가 아예 없는 구조체 / 어떤 타입에 대해 트레이트를 구현하고 싶지만 타입 내부에 어떤 데이터를 저장할 필요는 없을 경우 유용 (AlwaysEqual 라는 이름으로 선언)
4. 구조체는 중간중간 쉼표를 사용해야 할 수도 있고, 중괄호도 출력해야 할 수도 있도, 필드 일부를 생략해야 할 수도 있는 등 여러가지가 가능하다. 
    그래서 러스트는 이런 애매한 상황에 우리가 원하는 걸 임의로 예상해서 제고하려 들지 않기 때문에, 구조체에는 println! 및 {} 자리표시자와 함께 사용하기 위한 Display 구현체가 기본 제공되지 않는다.
    {} 내에 :?를 추가하는 건 println!에 Debug라는 출력 형식을 사용하고 싶다고 전달하는 것과 같다.
    러스트는 디버깅 정보를 출력하는 기능을 자체적으로 가지고 있지만 우리가 만든 구조체에 해당 기능을 적용하려면 명시적인 동의가 필요하다. -> #[derive(Debug)] 외부 속성을 작성해야됨

#######20250813#################
1. 동적 계획법(메모이제이션) : 재귀 함수를 효율적으로 만들어주는 기법이다. 이미 계산한 값을 저장해 두어 동일한 계산을 반복하지 않도록 하는 방식이다. 
    -> 피보나치 수열 같은 문제에서 중복 재귀 호출을 방지해 속도를 크게 개선할 수 있다.

########20250814###############
1. 메서드(method) : 함수와 유사. fn 키워드와 함수명으로 선언하고, 매개변수와 반환 값을 가지며, 다른 어딘가로부터 호출될 때 실행된다. 
    -> 하지만 함수와 달리 구조체 컨텍스트에 정의되고 (열거형이나 트레이트 객체 안에서 정의 되기도함) 첫 번째 매개변수가 항상 self라는 차이점이 있다.
    -> 메서드 문법은 차례대로 인스턴스, 점, 메서드명, 괄호 및 인수로 구성
2. 함수 대신 메서드를 사용하는 주된 이유 : 메서드 구문을 제공하고 모든 메서드 시그네처 내에서 self 타입을 반복할 필요가 없다는 것 외에도 코드를 더 조직적으로 만들기 위해서 이다.
    -> 향후 우리가 제공하는 라이브러리를 사용하는 사람들이 우리가 만든 기능과 관련된 코드를 라이브러리 곳곳에서 찾아내야 하는 것보다는 하나의 impl블록 내에 이 타입의 인스턴스로 할 수 있는 모든 것들을 모아두는 것
3. 러스트는 구조체 필드에 대한 게터(getter)를 자동으로 만들지 않는다. -> 필드를 비공개(private) 메서드는 공개(public)로 만들 수 있다.
    -> 게터는 어떤 타입의 공개 API로써 어떤 필드에 대해 읽기 전용 접근만 허용하고자 하는 경우 유용하다.
4. 러스트에 -> 연산자는 없다. -> 러스트에는 자동 참조 및 역참조라는 기능이 있고, 메서드 호출에 이 기능이 포함되어 있기 떄문이다.
    (C 나 C++언어에서는 메서드 호출에 사용하는 연산자)
5. 열거형 : 어떤 값이 여러 개의 가능한 값(variant)의 집합 중 하나라는 것을 나타내는 방법을 제공한다. ex) Rectangle이 Circle과 Triangel을 포함하는 다양한 모양들의 집합 중 하나라고 표현하고 싶을 수 있다.
6. Option<T> : 러스트에는 널(null) 개념이 없다. 하지만 값의 존재 혹은 부재의 개념을 표현할 수 있는 열거형이 바로 Option<T>이다.

########20250816#############
1. match : 매우 강려한 제어 흐름 연산자 / 일련의 패텀에 대해 어떤 값을 비교한 뒤 어떤 패턴에 매치되었는지를 바탕을 코드를 수행하도록 도와준다.
    -> 패턴은 리터럴 값, 변수명, 와일드카드 등 다양한 것으로 구성될 수 있다.
    -> match의 힘은 패턴의 표현성으로부터 오며 컴파일러는 모든 가능한 경우가 처리되는지 검사한다.
    -> match의 표현식은 동전분류기를 생각해보면 된다. 동전들의 다양한 크기의 구멍들이 있는 트랙으로 동전이 떨어지고 각기 맞는 크기별로 동전이 들어가는 방식
    -> match의 표현식이 실행될 때, 결과값을 각 갈래의 패턴에 대해서 순차적으로 비교한다.
2. 포과 패턴(catch-all) : 특별하게 나열되지 않은 나머지 모든 값에 대해 마지막 패턴이 매칭되는 패턴
    -> 패턴들은 순차적으로 평가되므로 마지막에 포괄적인 갈래를 위치시켜야 한다 / 포괄적인 갈래를 이보다 앞에 두면 그 뒤에 있는 갈래를 결코 실행될 수 없다.
    -> 만약 포괄 패턴 뒤에 갈래를 추가하면 러스트는 이에 대해 경고를 준다.
    -> other 혹은 _ 를 사용한다.

########20250818###############
1. if let : if와 let을 조합하여 하나의 패턴만 매칭시키고 나머지 경우는 무시하도록 값을 처리하는 간결한 방법 제공
    -> if let은 '='로 구분된 패턴과 표현식을 입력받는다. / 보일러 플레이트 코드를 덜 쓰게 된다.
        -> match가 강제했던 철저한 검사를 안하게 된다. -> if let은 한 패턴에 매칭될 때만 코드를 실행하고 다른 경우는 무시하는 match문을 작성할 때 사용하는 '문법 설당' 이다.
    -> else도 사용가능하다.
2. 열거형 값에 데이터가 있는 경우 처리해야 하는 경우의 수에따라 match나 if let을 사용하여 해당 값을 추출하여 사용할 수 있다.
3. 프로젝트를 패키지, 크레이트, 모듈로 관리하기
    -> 프로젝트 규모가 커지면 코드를 여러 모듈, 여러 파일로 나누어 관리해야 한다. 한 패키지에는 여러 개의 바이너리 크레이트와 (원할경우) 라이브러리 크레이트가 포함될 수 있으므로,
        커진 프로젝트의 각 부분을 크레이트로 나눠서 외부 라이브러리처럼 쓸 수 있다.
    -> 세부 구현을 캡슐화하면 더 고수준에서 코드를 재사용할 수 있는 방법에 대해서도 설명한다. 일단 어떤 연산을 구현하면 그 구현체의 작동 방식을 몰라도 다른 코드에서 공개 인터페이스를 통해 
        해당 코드를 호출할 수 있다, 코드를 작성하는 방식에 따라 다른 코드가 사용할 수 잇는 공개 부분과 변경 권한을 작성자에게 남겨두는 비공개 구현 세부 사항이 정의된다.
        (스코드 개념도 관련됨)
    -> 러스트에는 코드 조직화에 필요한 기능이 여럿 있다. 어떤 세부 정보를 외부에 노출할지, 비공개로 둘지, 프로그램의 스코프 내 어떤 이름이 있는지 등 다양하다 이를 '모듈 시스템' 이라고 함.
        -> 패키지 : 크레이트를 빌드하고, 테스트하고, 공유하는 데 사용하는 카고 기능이다. / 일련의 기능을 제공하는 하나 이상의 크레이트로 구성된 번들
            -> 패키지에는 이 크레이트들을 빌드하는 법이 설명된 Cargo.toml이 포함되어 있다. 카고는 실제로 코드를 빌드하는 데 사용하는 커맨드 라인 도구의 '바이너리 크레이트'가 포함된 패키지
            -> 패키지에는 여러 개의 바이너리 크레이트가 원하는 만큼 포함될 수 있지만, 라이브러리 크레이트는 하나만 넣을 수 있다.
            -> 패키지에는 적어도 하나 이상의 크레이트가 포함되어야 하며, 이는 라이브러리든 바이너리든 상관없다.
        -> 크레이트 : 라이브러리(바이너리도 됨)나 실행 가능한 모듈로 구성된 트리 구조이다. / 러스트가 컴파일 한 차례에 고려하는 가장 작은 코드 단위 / 여러 모듈을 담을 수 있음
            / 모듈은 이 크레이트와 함께 컴파일되는 다른 파일들에 정의되어 있을 수도 있다. 
            -> 바이너리 크레이드 : 커맨드 라인 프로그램이나 서버처럼 실행 가능한 실행파일로 컴파일할 수 있는 프로그램(main 함수 포함)
            -> 라이브러리 크레이트 : main함수 가지고 있지 않고 실행파일 형태로 컴파일되지 않음 / 여러 프로젝트에서 공용될 의도로 만들어진 기능들이 정의됨
                / 보톤 러스타시안들이 '크레이트'라고 말하면 대부분은 이 라이브러리 크레이트를 의미한다. 일반적인 프로그래밍 개념에서의 '라이브러리'와 혼용됨.
            -> 크레이트 루트 : 러스트 컴파일러가 컴파일을 시작하는 소스 파일이고, 크레이트의 루트 모듈을 구성한다 
        -> 모듈 과 use : 구조, 스코프를 제어하고, 조직 세부 경로를 감추는 데 사용한다.
            -> 크레이트 루트부터 시작 : 크레이트를 컴파일할 때 컴파일러는 먼저 크레이트 루트 파일을 본다.(보통 라이브러리 크레이트는 lib.rs를 바이너리 크레이트는 main.rs이다)
            -> 모듈 선언 : 크레이트 루프 파일에는 새로운 모듈을 선언할 수 있다. 
                ex. mod garden; 이라킄 코드로 garden 모듈을 선언할 수 있다. 
            -> 모둘 내 코들로의 경로 : 일단 모듈이 크레이트의 일부로서 구성되면, 공개 규칙이 허용하는 한도 내에서라면 해당 코드의 경로를 사용하여 동일한 크레이트의 어디에서든 이 모듈의 코드를 참조할 수 있음
            -> 비공개 vs 공개 : 모둘 내의 코드는 기본적으로 부모 모듈에게 비공개(private)이다. 모듈은 공개(public)로 만들려면, mod 대신 pub mod를 써서 선언해야됨.
            -> use 키워드 : 어떤 스코프 내에서 use 키워드는 긴 경로의 반복을 불이기 위한 어떤 아이템으로의 단축경로를 만들어 준다.
                -> use키워드와 경로를 작성하는 건 파일 시스템에서 심볼릭 링크(sysbolic link)를 생성하는 것과 유사하다.
        -> 경로 : 구조체, 함수, 모듈 등의 이름을 지정한다.
            -> 절대 경로(absolute path) : 크레이트 루트로부터 시작되는 전체 경로이다. 외부 크레이트로부터의 코드에 대해서는 해당 크레이트 이름으로 절대 경로가 시작되고 현재의 크레이트로부터의 코드에 대해서는
                'crate'리터럴로 부터 시작된다.
            -> 상대 경로(relative path) : 현재의 모듈을 시작점으로 하여 self, super 혹은 모듈 내의 식별자를 사용한다.
            -> 절대 경로, 상대경로 뒤에는 '::'으로 구분된 식별자가 하나 이상 따라온다.

############20250820#############
1. 러스트에서는 (함수, 메서드, 구조체, 열거형, 모듈, 상수) 모든 아이템이 기본적으로 부모 모듈에 대해 비공개이다.
    -> 부모 모듈 내 아이템은 자식 모듈 내 비공개 아이템을 사용할 수 없지만, 자식 모듈 내 아이템은 부모 모듈 내 아이템을 사용할 수 있다.
        -> 자식 모듈의 세부 구현은 감싸져서 숨겨져 있지만, 자식 모듈 내에서는 자신이 정의된 컨텍스트를 볼 수 있기 때문이다. 
2. 구조체 정의에 pub를 쓰면 구조체는 공개되지만, 구조체의 필드는 비공개로 유지된다. 공개여부는 각 필드마다 정할 수 있다. -> 구조체 필드는 공개로 하지 않는 것이 종종 유용하므로 pub을 명시하지 않는 한 기본적으로 비공개
3. 열거형은 공개로 지정할 경우 모든 배리언트가 공개된다. -> 열겨형은 그 배리언트가 공개되지 않는다면 큰 쓸모가 없다. 
    -> 열거형의 모든 배리언트에 대해 전부 pub를 붙이는 것은 귀찮은 일이 될 것이므로, 열거형의 배리언트는 기본적으로 공개이다.

##########20250821###############
1. 컬렉션(collection) : 다수의 값을 담을 수 있다. 내장된 배열(build in arrray) 이나 튜플과 달리 컬렉션들이 가리키는 데이터는 '힙'에 저장된다.
    -> 힙에 저장되는 의미 : 데이터의 양이 컴파일 타임에 결정되지 않아도 되며 프로그램 실행 중에 늘어나거나 줄어들수 있다.
    -> 각 컬렉션 종류는 서로 다른 크기와 비용을 가지고 있다.
2. 벡터(vector) : 여러 개의 값을 서로 붙어 있게 저장할 수 있도록 해준다.(단일 데이터 구조) / 같은 타입의 값만을 저장할 수 있다. / 힙에 저장된다.
    -> 벡터는 제네릭(generic)을 이용하여 구현
    -> 열거형(다양한 타입의 배리언트)도 벡터로 담을 수 있다. -> 하나의 벡터의 한가지 벡터만 담을 수 있지만 열거형의 경우 모든 배리언트들은 해당 열거형 타입과 같은 타입으로 간주하기 때문이다.
        -> 만약 런타임에 프로그램이 벡터에 저장할 모든 타입 집합을 알지 못하면 열거형을 이용한 방식은 사용할 수 없다. 대신 '트레이트 객체(trait object)'를 이용할 수 있다.
    -> struct와 마찬가지로 벡터는 스코프를 벗어날 때 해제된다.
3. 문자열(string) : 문자(character)의 모음이다. / 바이트의 컬렉션으로 구현되어 있다. / 참조형인 &str형태로 사용하는 문자열 슬라이스 str이다.
    -> String타입은 언어의 핵심 기능에 구현된 것이 아니고 러스트의 표준 라이브러리를 통해 제공되며, 커질 수 있고, 가변적이며, 소유권을 갖고 있고, UTF-8으로 인코딩된 문자열 타입이다.
4. 해시맵(hashmap) : 어떤 값을 특정한 키와 연관지어 주도록 해분다. / 해시 함수(hashing function)을 사용하여 매핑한 것을 저장한다. / 힙에 저장된다.

#############20250823############
1. iterator : 데이터를 순차적으로 처리하는 반복자 / 트레잇(trait)으로 데이터 구조에 따라 이터레이터를 생성하고 메서드를 체인 형태로 결합해 효율적인 처리 가능
    -> 다양한 이터레이터 어댑터(map(), filter(), skip(), 등)를 사용해 데이터 스트림을 원하는 대로 가공, 변환 가능
2. collect() : 이터레이터가 순회하는 요소들을 모아, 지정한 컬렉션 (여기서는 String)으로 다시 합친다.
3. chars() : 문자열을 유니코드 문자(char) 단위로 분리하는 반복자(iterator)를 생성한다. 문자열을 한 글자씩 안전하게 순회하는 방법이다.
    -> next() : 메서드는 이 이터레이터에서 다음 요소(여기서는 다음 문자)를 Option<char> 타입으로 반환한다. -> Some으로 감싼 반복자의 아이템을 하나씩 반환하고, 반복자가 종료될 때는 None을 반환

#############20250825############
1. panic : 기본적으로 실패 메시지를 출력하고, 되감고(unwind), 스택을 청소하고 종료하기. -> '되감기' 라는 것은 패닉을 발생시킨 함수로부터 거꾸로 훑어가면서 데이터를 청소한다는 의미.
    -> 간단한 작업이 아님 그랙서 데이터 정리 작업 없이 즉각 종료되는 '그만두기(abortin)'을 선택할 수 도 있다.
    -> 그만두기 : Cargo.toml에서 적합한 [profile.release] 에서 panic = 'abort'를 추가한다.
2. unwrap : match 메서드와 비슷한 구현을 한 숏컷 메서드 이다. / panic!의 기본 메시지를 출력한다.
3. expect : 매개변수로 전달한 에러 메시지를 출력한다.
4. 에러 전파하기(propagating) : 함수의 구현체에서 실패할 수도 있는 무언가를 호출할 때, 이 함수에서 에러를 처리하는 대신 이 함수를 호출하는 코드 쪽으로 에러를 반환하여 그쪽에서 수행할 작업을 결정하도록 한다.
    -> 호출하는 코드 쪽에 더 많은 제어권을 주는 것이다. 그 이유는 호출하는 코드 쪽에는 에러를 어떻게 처리해야 하는지 결정하는 정보와 로직이 여러분의 코드 컨테스트 네에서 활용할 수 있는 것 보다 더 많이 있을 수 있기 때문이다.
5. ? 연산자 : 러스트에서는 에러를 전파하는 패턴이 너무 흔하여 이를 더 쉽게 해주는 연산자이다. / 호환 가능한 반환 타입을 가진 함수에서만 사용될 수 있다.
    -> 해당 연산자 사용 시 match 표현식과 달리 에러 값들은 from 함수를 거친다. 
    -> from : 표준 라이브러리 내의 From 트레이트에 정의되어 있으며 어떤 값의 타입을 다른 타입으로 변환하는데 사용한다.
        -> from 함수를 호출하면 ? 연산자가 얻게되는 에러를 ? 연산자가 사용된 현재 함수의 반환 타입에 정의된 에러 타입으로 변환한다.
        -> 어떤 함수가 다양한 종류의 에러로 인해 실패할 수 있지만, 모든 에러를 하나의 에러 타입으로 반환할 때 유용하다.

##########20250827################
1. generic : 중복되는 개념을 효율적으로 처리하기 위한 도구 / 구체(concrrete) 타입 혹은 기타 속성에 대한 추상화된 대역이다.
    / 컴파일과 실행 시점에 제네릭들이 실제로 무슨 타입으로 채워지는지 알 필요 없이 제네릭의 동작이나 다른 제네릭과의 관계를 표현할 수 있다.
    / ex. Option<T>, Vec<T>, HashMap<K, V>, Result<T, E>
    -> 함수 시그니처나 구조체의 아이템에 다양한 구체적 데이터 타입을 사용할 수 있도록 정의할 수 있다. 
2. 단현성화(monomorphization) : 제네릭 코드를 실제 구체 타입으로 채워진 코드로 바꾸는 과정
3. trait : 특정한 타입이 가지고 있으면서 다른 타입과 공유할 수 있는 기능을 정의 / 공통된 기능을 추상적으로 정의할 수 있다. / 트레이트 바운드(trait bound)를 이용하면 어떤 제네릭 타입자리에 특정한 동작을 갖춘 타입이 올 수 있음을 명시할 수 있다.
    -> 제약 사항 : 트레이트나 트레이트를 구현할 타입 둘 중 하나는 반드시 자신의 크레이트 것이어야 해당 타입에 대한 트레이트를 구현할 수 있다는 점(고아 규칙)
4. lifetime : 어떤 타입이 원하는 동작이 구현되어 있음을 보장하기 위한 것이 아니라, 어떤 참조자가 필요한 기간 동안 유효함을 보장하도록 한다.
    -> 모든 참조가는 '라이프타임'이라는 참조자의 유효성을 보장하는 범위를 갖는다. / 대부분의 타입 암묵적으로 추론되듯, 라이프타임도 암묵적으로 추론 가능.
    -> 참조자의 수명이 여러 방식으로 서로 연관될 수 있는 경우에는 라이프타임을 명시해 주어야 한다.
    -> 주목적은 '댕글링 참조(dangling reference)' 방지이다.
        -> 댕글링 참조 : 프로그램이 참조하려고 한 데이터가 아닌 엉뚱한 데이터를 참조하게 되는 원인이다.
    -> 명시 문법 : 라이프타임 매개변수의 이름은 어퍼스트로피(')로 시작해야 하며 보통은 제네릭 타입처럼 매우 짧은 소문자로 정한다.
    -> 라이프타임을 함수에 명시할 때는 함수 본문이 아닌, 함수 시그니처에 적는다.
    -> 근본적인 역할은 함수의 다양한 매개변수와 반환 값의 라이프타임을 연결하는 데에 있다. 한번 라이프타임을 연결해 주고 나면, 러스트는 해당 정보를 이용해 댕글링 포인터 생성을 방지하고, 메모리 안전 규칙을 위배하는 연산을 배제한다.

#########20250829###################
1. static lifetime : 'static 이라는 특별한 라이프타임 / 해당 참조자가 프로그램의 전체 생애주기 동안 살아있음을 의미한다.
    -> 모든 문자열 리터럴은 'static 라이프타임을 가진다.
2. 테스트 : 테스트할 코드가 의도대로 기능하는지 검증하는 함수이다. 테스트 함수는 보통 본문에서 세 가지 동작을 수행한다.
    -> 1) 필요한 데이터나 상태 설정 2) 테스트할 코드 실행 3) 의도한 결과가 나오는지 확인
    -> test 속성이 어노테이션된 함수 이다. 속성은 러스트 코드 조각에 대한 메타데이터이다. ex. derive 속성 
    -> 함수 fn 이전 줄에 #[test]를 추가하면 테스트 함수로 변경된다. cargo test 명령어로 실행되며 이 명령을 실행하면 러스트는 속성이 표시된 함수를 실행하고 결과를 보고하는 테스트 실행 바이너리를 빌드한다.
    -> 여러 테스트를 실행할 때는 기본적으로 스레드를 사용해 병렬 실행된다.

##########20250830################
1. 유닛 테스트(unit test) : 단위 테스트 / 작고 더 집중적이다. 한 번에 하나의 모듈만 테스트하고 모듈의 비공개 인터페이스도 테스트할 수 있다.
2. 통합 테스트(integration test) : 완전히 라이브러리 외부에 위치하며, 외부 코드에서 사용할 때와 똑같은 방식을 사용한다. 
3. grep(globally search a regular expression and print) : 고전적인 커맨드 라인 검색 도구 / 어떤 특정한 파일에서 특정한 문자열을 검색한다.

##########20250901################
1. 테스트 주도 개발(Test-Driven Development, TDD)
    1) 실패하는 테스트를 작성하고 실행하여, 여러분이 예상한 이유대로 실패하는지 확인한다.
    2) 이 새로운 테스트를 통과하기 충분한 정도의 코드만 작성하거나 수정한다.
    3) 추가하거나 변경한 코드를 리팩터링하고 테스트가 계속 통과하는지 확인한다.
    4) 1단계로 돌아간다. 
2. 표준출력(standard output, stdout) : 범용적인 정보를 위한 출력
3. 표준에러(standard error, stderr) : 에러 메시지를 위한 출력 
4. 함수형 프로그래밍 : 함수를 값처럼 인수로 넘기는 것, 다른 함수들에게서 결과값으로 함수들을 반환하는 것, 나중에 실행하기 위해 함수를 변수에 할당하는 것
5. 클로저 : 변수에 저장하거나 다른 함수에 인수로 전달할 수 있는 익명 함수 / 정의된 스코프에서 값을 캡쳐할 수 있다.

##########20250902##############
1. 함수와 클로저 간의 차이점
    -> 클로저는 보통 fn 함수에서처럼 매개변수 혹은 반환 값의 타입을 명시하도록 요구하지 않는다. 함수의 타입 명시는 그 타입이 사용자들에게 노출되는 명시적인 인터페이스의 일부분이기 때문에 요구된다. 
        -> 이러한 인터페이스를 엄격하게 정의하는 것은 함수가 어떤 타입의 값을 사용하고 반환하는지에 대해 모두가 납득하는 것을 보증하는 데에 중요하다. 클로저는 함수처럼 노출된 인터페이스로 사용되지 않는다.
        -> 클로저는 이름이 지어지거나 라이브러리의 사용자들에게 노출되지 않은 채로 변수에 저장되고 사용된다. 
    -> 클로저는 통상적으로 짧고 임의의 시나리오가 아니라 짧은 컨텍스트 내에서만 관련된다.
    -> 클로저는 처음 반환되는 타입으로 반환 타입이 고정된다.
    -> 클로저는 세 가지 방식으로 자신의 환경으로부터 값을 캡처할 수 있다. -> 불변으로 빌려오기, 가변으로 빌력오기, 소유권 이동
2. 반복자 패턴 : 일련의 아이템들에 대해 순서대로 어떤 작업을 수행할 수 있도록 해준다. 반복자는 각 아이템을 순회하고, 언제 시퀀스가 종료될지 결정하는 로직을 담당한다. 
    -> 러스트의 반복자는 게으르다. -> 반복자를 사용하는 메서드를 호출하여 반복자를 소비하기 전까지는 동작을 하지 않는다.
    -> 벡터처럼 인덱스를 사용할 수 있는 자료구조 뿐만 아니라, 많은 다른 종류의 시퀀스에 대해 동일한 로직을 사용할 수 있도록 더 많은 유연성을 제공한다. 
    -> ex. Iterator 트레이트와 next 메서드 

############20250903#############
1. 릴리즈 프로필(release profile) : 설정값을 가지고 있는 미리 정의된, 커스터마이징 가능한 프로필
    -> dev profile : cargo build를 실행할 때 사용(개발에 적합한 기본값으로 정의됨) / release profile : cargo build release를 실행할 때 사용(릴리즈 빌드용 설정을 기본값으로 정의됨)
    -> Cargo.toml파일에 [profile.*]섹션을 명시적으로 추가하지 않았을 경우 적용되는 각 프로필의 기본설정이 있다. 

############20250904##############
1. 포인터(pointer) : 메모리의 주소값을 담고 있는 변수에 대한 일반적인 개념.
2. 스마트 포인터(smart pointer) : 포인터처럼 작동할 뿐만 아니라 추가적인 메타데이터와 능력들도 가지고 있는 데이터구조.
    -> 참조자는 데이터를 빌리기만 하는데 스마트 포인터는 가리킨 데이터를 소유한다. 보통 구조체를 이용하여 구현된다. Deref 와 Drop 트레이트로 구현한다.
    -> Deref 트레이트 : 스마트 포인터 구조체의 인스턴스가 참조자처럼 동작하도록 하여 참조자 혹은 스마트 포인터와 함께 작동하는 코드를 작성할 수 있도록 해준다.
        -> 역참조 연산자(dereference operator) * 동작의 커스터 마이징을 가능하게 해준다.
        -> 역참조 강제 변환(deref coercion) : Deref를 구현한 어떤 타입의 참조자를 다른 타입의 참조자로 바꿔준다.
        -> DerefMut 트레이트를 사용하여 가변 참조자에 대한 * 연산자를 오버라이딩 할 수 있다. 
    -> Drop 트레이트 : 스마트 초인터의 인스턴스가 스코프 밖으로 벗어났을 때 실행되는 코드를 커스터마이징 가능하도록 해준다. 파일이나 네트워크 연결 같은 자원 해제에 사용되게 할 수 있다.
        -> 소멸자(desturctor) : 인스턴스를 정리하는 함수에 대한 일반적인 프로그래밍 용어. 생성자(constructor)와 유사한 용어
    -> ex. 참조 카운팅(reference counting), 박스(Box)
3. Box<T> : 스택이 아니라 힙에 데이터를 저장할 수 있도록 해준다. 스택에 남는 것은 힙 데이터를 가리키는 포인터이다. 성능 측면에서의 오버헤드가 없다. 하지만 여러 추가 기능도 없다.
    -> 자주 사용하는 시기
        -> 컴파일 타임에는 크기를 알 수 없는 타입이 있는데, 정확한 크기를 요구하는 컨텍스트 내에서 그 타입의 값을 사용하고 싶을 때
        -> 커다란 데이터를 가지고 있고 소유권을 옮기고 싶지만 그렇게 했을 때 데이터가 복사되지 않을 것을 보장하고 싶을 때
        -> 어떤 값을 소유하고 이 값의 구체화된 타입보다는 특정 트레이트를 구현한 타입이라는 점만 신경 신경 쓰고 싶을 때
    -> 재귀적 타입(recursive type)의 값은 자신 안에 동일한 타입의 또 다른 값을 담을 수 있다. -> 러스트는 문제가 됨 -> 컴파일 타임에 어떤 타입이 얼마만큼의 공간을 차지하는지 알아야 하기 때문이다.
        -> 러스트의 경우 박스를 이용함 -> 박스는 크기를 갖고 있으므로, 재귀적 타입의 정의에 박스를 집어넣어서 재귀적 타입을 가능하게 할 수 있다.
4. Rc<T> : 참조 카운팅(reference counting)의 약자 / 명시적으로 복수 소유권을 가능하게 하는 타입. 어떤 값의 참조자 개수를 계속 추적하여 해당 값이 계속 사용 중인지를 판단한다. 
    -> 프로그램의 여러 부분에서 읽을 데이터를 힙에 할당하고 싶은데 컴파일 타임에는 어떤 부분이 그 데이터를 마지막에 이용하게 될지 알 수 없는 경우 사용된다.
    -> 오직 싱글스레드 시나리오 용이다. 
5. 내부 가변성(interior mutability) : 어떤 데이터에 대한 불변 참조자가 있을 때라도 데이터를 변경할 수 있게 해주는 러스트의 디자인 패턴 -> 보통 이러한 동작은 대여 규칙에 의해 허용되지 않음.
    -> RefCell<T> : 가지고 있는 데이터에 대한 단일 소유권을 나타낸다. -> 오직 싱글스레드 시나리오 용이다. -> 내부의 값을 변경할 수 있다. 
        -> Box<T>의 차이점 : Box<T>를 이용하면 대여 규칙의 불변성은 '컴파일 타임'에 집행된다. RefCell<T>는 이 불변성은 '런타임'에 집행된다.
            -> Box<T>는 컴파일 에러 / RefCell<T>는 panic!을 일으키고 종료.
        -> borrow : 스마트 포인터 타입인 Ref<T>를 반환한다.
        -> borrow_mut : 스마트 포인터 타입 RefMut<T>를 반환한다. 

###############20250908##########################
1. 순환 참조 : 순환 참조는 메모리 누수를 발생시킬 수 있다. -> 순환 참조를 만드는 것은 프로그램의 논리적 버그로서, 자동화된 테스트, 코드 리뷰, 그 외 소프트웨어 개발 연습 등을 통해 최소화해야 할것이다. 

################20250909#######################
1. 동시성 프로그래밍(concurrent programming) : 프로그램의 서로 다른 부분이 독립적으로 실행.
2. 병렬 프로그래밍(parallel programming) : 프로그램의 서로 다른 부분이 동시에 실행.
3. 스레드 : 프로그램 내에서 동시에 실행되는 족립적인 부분들을 실행하는 기능.
4. move : 클로저가 환경으로부터 사용하는 값의 소유권을 갖게 되어 한 스레드에서 다른 스레드로 소유권이 이동된다. (13장 - 클로저 파트에서 사용됨)
    -> 러스트의 대여에 대한 보수적인 기본 기준을 무효화한다. -> 소유권 규칙을 위반하지 않도록 해준다.

##############202050910#######################
1. 뮤텍스(mutex) : 공유 메모리를 위한 더 일반적인 동시성 기초 재료 / 상호 배제(mutual exclusion)의 줄임말 / 한번에 하나의 스레드만 데이터 접근을 허용한다.
    -> 락(lock) : 누가 현재 배타적으로 데이터에 접근하느느지 추적하는 뮤텍스의 일부에 해당하는 데이터 구조 / 잠금 시스템을 통해 가지고 있는 데이터를 보호(guard)하는 것으로 묘사된다.
    -> 사용하기 어렵다는 평판 -> 데이터를 사용하기 전에는 반드시 락을 얻는 시도를 해야됨 / 데이터의 사용이 끝났다면 반드시 언락을 해야 다른 스레드들이 락을 얻을 수 있다.
2. Send 마커 트레이트 : Send가 구현된 타입의 소유권이 스레드 사이에서 이동될 수 있음을 나타낸다. 
    -> Send 타입으로 구성된 모든 타입은 자동으로 Send로 마킹된다. 원시 포인터(raw pointer)를 빼고 거의 모든 기초 타입이 Send이다.
3. Sync 마커 트레이트 : Sync가 구현된 타입이 여러 스레드로부터 안전하게 참조 가능함을 나타낸다. 
    -> &T(T의 불변 참조자)가 Send이면, 즉 참조자가 다른 스레드로 안전하게 보내질 수 있다면, T는 Sync한다. 

#############20250912#######################
1. 패턴(pattern) : 복잡하거나 단순한 타입의 구조와 매칭을 위한 러스트의 특수 문법이다. match 표현 및 기타구문과 함께 사용하면 프로그램 흐름을 더 잘 제어할 수 있다.
    -> 리터럴 값(literals) / 분해한(destructured)배열, 열거형, 구조체, 튜플 / 변수 / 와일드 카드(wild card) / 자리표시자(placeholder)
2. 반박 불가능한(irrefutable) 패턴 : 넘겨진 모든 가능한 값에 대해 매칭되는 패턴
3. 반박 가능(refutable) 패턴 : 일부 가능한 값에 대해 매칭에 실패할 수 있는 패턴